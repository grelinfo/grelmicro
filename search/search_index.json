{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Grelmicro","text":"<p>Grelmicro is a lightweight framework/toolkit which is ideal for building async microservices in Python.</p> <p>It is the perfect companion for building cloud-native applications with FastAPI and FastStream, providing essential tools for running in distributed and containerized environments.</p> <p> </p> <p>Documentation: https://grelinfo.github.io/grelmicro/</p> <p>Source Code: https://github.com/grelinfo/grelmicro</p>"},{"location":"#overview","title":"Overview","text":"<p>Grelmicro provides essential features for building robust distributed systems, including:</p> <ul> <li>Backends: Technology-agnostic design supporting Redis, PostgreSQL, and in-memory backends for testing.</li> <li>Logging: Easy-to-configure logging with support of both text or JSON structured format.</li> <li>Resilience Patterns: Implements common resilience patterns like retries and circuit breakers.</li> <li>Synchronization Primitives: Includes leader election and distributed lock mechanisms.</li> <li>Task Scheduler: A simple and efficient task scheduler for running periodic tasks.</li> </ul> <p>These features address common challenges in microservices and distributed, containerized systems while maintaining ease of use.</p>"},{"location":"#logging","title":"Logging","text":"<p>The <code>logging</code> package provides a simple and easy-to-configure logging system.</p> <p>The logging feature adheres to the 12-factor app methodology, directing logs to <code>stdout</code>. It supports JSON formatting and allows log level configuration via environment variables.</p>"},{"location":"#resilience-patterns","title":"Resilience Patterns","text":"<p>The <code>resilience</code> package provides higher-order functions (decorators) that implement resilience patterns to improve fault tolerance and reliability in distributed systems.</p> <ul> <li>Circuit Breaker: Automatically detects repeated failures and temporarily blocks calls to unstable services, allowing them time to recover.</li> </ul>"},{"location":"#synchronization-primitives","title":"Synchronization Primitives","text":"<p>The <code>sync</code> package provides synchronization primitives for distributed systems.</p> <p>The primitives are technology agnostic, supporting multiple backends like Redis, PostgreSQL, and in-memory for testing.</p> <p>The available primitives are:</p> <ul> <li>Leader Election: A single worker is elected as the leader for performing tasks only once in a cluster.</li> <li>Lock: A distributed lock that can be used to synchronize access to shared resources.</li> </ul>"},{"location":"#task-scheduler","title":"Task Scheduler","text":"<p>The <code>task</code> package provides a simple task scheduler that can be used to run tasks periodically.</p> <p>Note: This is not a replacement for bigger tools like Celery, taskiq, or APScheduler. It is just lightweight, easy to use, and safe for running tasks in a distributed system with synchronization.</p> <p>The key features are:</p> <ul> <li>Fast &amp; Easy: Offers simple decorators to define and schedule tasks effortlessly.</li> <li>Interval Task: Allows tasks to run at specified intervals.</li> <li>Synchronization: Controls concurrency using synchronization primitives to manage simultaneous task execution (see the <code>sync</code> package).</li> <li>Dependency Injection: Use FastDepends library to inject dependencies into tasks.</li> <li>Error Handling: Catches and logs errors, ensuring that task execution errors do not stop the scheduling.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install grelmicro\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#fastapi-integration","title":"FastAPI Integration","text":"<ul> <li>Create a file <code>main.py</code> with:</li> </ul> <pre><code>from contextlib import asynccontextmanager\n\nimport typer\nfrom fastapi import FastAPI\n\nfrom grelmicro.logging.loguru import configure_logging\nfrom grelmicro.sync import LeaderElection, Lock\nfrom grelmicro.sync.redis import RedisSyncBackend\nfrom grelmicro.task import TaskManager\n\n\n# === FastAPI ===\n@asynccontextmanager\nasync def lifespan(app):\n    configure_logging()\n    # Start the lock backend and task manager\n    async with sync_backend, task:\n        yield\n\n\napp = FastAPI(lifespan=lifespan)\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n\n# === Grelmicro ===\ntask = TaskManager()\nsync_backend = RedisSyncBackend(\"redis://localhost:6379/0\")\n\n# --- Ensure that only one say hello world at the same time ---\nlock = Lock(\"say_hello_world\")\n\n\n@task.interval(seconds=1, sync=lock)\ndef say_hello_world_every_second():\n    typer.echo(\"Hello World\")\n\n\n@task.interval(seconds=1, sync=lock)\ndef say_as_well_hello_world_every_second():\n    typer.echo(\"Hello World\")\n\n\n# --- Ensure that only one worker is the leader ---\nleader_election = LeaderElection(\"leader-election\")\ntask.add_task(leader_election)\n\n\n@task.interval(seconds=10, sync=leader_election)\ndef say_hello_leader_every_ten_seconds():\n    typer.echo(\"Hello Leader\")\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Grelmicro depends on Pydantic v2+, AnyIO v4+, and FastDepends.</p>"},{"location":"#standard-dependencies","title":"<code>standard</code> Dependencies","text":"<p>When you install Grelmicro with <code>pip install grelmicro[standard]</code> it comes with:</p> <ul> <li><code>loguru</code>: A Python logging library.</li> <li><code>orjson</code>: A fast, correct JSON library for Python.</li> </ul>"},{"location":"#redis-dependencies","title":"<code>redis</code> Dependencies","text":"<p>When you install Grelmicro with <code>pip install grelmicro[redis]</code> it comes with:</p> <ul> <li><code>redis-py</code>: The Python interface to the Redis key-value store (the async interface depends on <code>asyncio</code>).</li> </ul>"},{"location":"#postgres-dependencies","title":"<code>postgres</code> Dependencies","text":"<p>When you install Grelmicro with <code>pip install grelmicro[postgres]</code> it comes with:</p> <ul> <li><code>asyncpg</code>: The Python <code>asyncio</code> interface for PostgreSQL.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"logging/","title":"Logging","text":"<p>The <code>logging</code> package provides a simple and easy-to-configure logging system.</p> <p>The logging feature adheres to the 12-factor app methodology, directing logs to stdout. It supports JSON formatting and allows log level configuration via environment variables.</p>"},{"location":"logging/#dependencies","title":"Dependencies","text":"<p>For the moment the <code>logging</code> package is only working with the <code>loguru</code> Python logging library. When <code>orjson</code> is installed, it will be used as the default JSON serializer for faster performance, otherwise, the standard <code>json</code> library will be used.</p> <p>Loguru is used as the logging library.</p> <p>For using <code>logging</code> package, please install the required dependencies:</p> Standardonly loguru (minimum)loguru and orjson (manual) <pre><code>pip install grelmicro[standard]\n</code></pre> <pre><code>pip install loguru\n</code></pre> <pre><code>pip install loguru orjson\n</code></pre>"},{"location":"logging/#configure-logging","title":"Configure Logging","text":"<p>Just call the <code>configure_logging</code> function to set up the logging system.</p> <pre><code>from grelmicro.logging import configure_logging\n\nconfigure_logging()\n</code></pre>"},{"location":"logging/#settings","title":"Settings","text":"<p>You can change the default settings using the following environment variables:</p> <ul> <li><code>LOG_LEVEL</code>: Set the desired log level (default: <code>INFO</code>).</li> <li><code>LOG_FORMAT</code>: Choose the log format. Options are <code>TEXT</code> and <code>JSON</code>, or you can provide a custom loguru template (default: <code>TEXT</code>).</li> </ul>"},{"location":"logging/#examples","title":"Examples","text":""},{"location":"logging/#basic-usage","title":"Basic Usage","text":"<p>Here is a quick example of how to use the logging system:</p> <pre><code>from loguru import logger\n\nfrom grelmicro.logging import configure_logging\n\nconfigure_logging()\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning message with context\", user=\"Alice\")\nlogger.error(\"This is an error message with context\", user=\"Bob\")\n\ntry:\n    raise ValueError(\"This is an exception message\")\nexcept ValueError:\n    logger.exception(\n        \"This is an exception message with context\", user=\"Charlie\"\n    )\n</code></pre> <p>The console output, <code>stdout</code> will be:</p> <pre><code>{\"time\":\"2024-11-25T15:56:36.066922+01:00\",\"level\":\"INFO\",\"thread\":\"MainThread\",\"logger\":\"__main__:&lt;module&gt;:7\",\"msg\":\"This is an info message\"}\n{\"time\":\"2024-11-25T15:56:36.067063+01:00\",\"level\":\"WARNING\",\"thread\":\"MainThread\",\"logger\":\"__main__:&lt;module&gt;:8\",\"msg\":\"This is a warning message with context\",\"ctx\":{\"user\":\"Alice\"}}\n{\"time\":\"2024-11-25T15:56:36.067105+01:00\",\"level\":\"ERROR\",\"thread\":\"MainThread\",\"logger\":\"__main__:&lt;module&gt;:9\",\"msg\":\"This is an error message with context\",\"ctx\":{\"user\":\"Bob\"}}\n{\"time\":\"2024-11-25T15:56:36.067134+01:00\",\"level\":\"ERROR\",\"thread\":\"MainThread\",\"logger\":\"__main__:&lt;module&gt;:14\",\"msg\":\"This is an exception message with context\",\"ctx\":{\"user\":\"Charlie\",\"exception\":\"ValueError: This is an exception\"}}\n</code></pre>"},{"location":"logging/#fastapi-integration","title":"FastAPI Integration","text":"<p>You can use the logging system with FastAPI as well:</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\nfrom loguru import logger\n\nfrom grelmicro.logging import configure_logging\n\n\n@asynccontextmanager\ndef lifespan_startup():\n    # Ensure logging is configured during startup\n    configure_logging()\n    yield\n\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef root():\n    logger.info(\"This is an info message\")\n    return {\"Hello\": \"World\"}\n</code></pre> <p>Warning</p> <p>It is crucial to call <code>configure_logging</code> during the lifespan of the FastAPI application. Failing to do so may result in the FastAPI CLI resetting the logging configuration.</p>"},{"location":"resilience/","title":"Resilience Patterns","text":"<p>The <code>resilience</code> package provides higher-order functions (decorators) that implement resilience patterns to improve fault tolerance and reliability in distributed systems.</p> <ul> <li>Circuit Breaker: Automatically detects repeated failures and temporarily blocks calls to unstable services, allowing them time to recover.</li> </ul> <p>Note</p> <p>Additional resilience patterns may be added in the future. Currently, the circuit breaker is the primary mechanism provided for building robust microservices.</p>"},{"location":"resilience/#circuit-breaker","title":"Circuit Breaker","text":"<p>A Circuit Breaker prevents repeated failures when calling unreliable services. It monitors call outcomes and, after too many consecutive failures, \"opens\" to block further calls for a period, allowing recovery.</p> <p>Why Circuit Breakers?</p> <ul> <li>Prevent cascading failures</li> <li>Improve stability and user experience</li> <li>Provide observability into service health</li> </ul>"},{"location":"resilience/#state-machine","title":"State Machine","text":"<p>The Circuit Breaker has three normal states and two manual (forced) states:</p> State Description CLOSED Normal operation, calls are allowed. OPEN Calls are blocked to allow recovery. HALF_OPEN Allows limited calls to test if the service has recovered. FORCED_OPEN Manual state to block calls regardless of health checks. FORCED_CLOSED Manual state to allow calls regardless of health checks."},{"location":"resilience/#usage","title":"Usage","text":"<pre><code>from grelmicro.resilience.circuitbreaker import CircuitBreaker\n\ncircuit_breaker = CircuitBreaker(\n    \"system_name\", ignore_exceptions=FileNotFoundError\n)\n\n\nasync def async_context_manager():\n    async with circuit_breaker:\n        print(\"Calling external service...\")\n\n\n@circuit_breaker\nasync def async_call():\n    print(\"Calling external service...\")\n\n\ndef sync_context_manager():\n    with circuit_breaker.from_thread:\n        print(\"Calling external service from AnyIO worker thread...\")\n\n\n@circuit_breaker\ndef sync_call():\n    print(\"Calling external service from AnyIO worker thread...\")\n</code></pre> <p>Warning</p> <p>Thread Safety: The Circuit Breaker is not thread-safe. Decorated sync functions or <code>from_thread</code> methods will ensure state change logic runs safely within the async event loop. Threaded usage is supported only in AnyIO worker threads and may be slower than pure async usage.</p>"},{"location":"sync/","title":"Synchronization Primitives","text":"<p>The <code>sync</code> package provides synchronization primitives for distributed systems.</p> <p>The primitives are technology agnostic, supporting multiple backends (see more in the Backends section).</p> <p>The available primitives are:</p> <ul> <li>Leader Election: A single worker is elected as the leader for performing tasks only once in a cluster.</li> <li>Lock: A distributed lock that can be used to synchronize access to shared resources.</li> </ul> <p>The synchronization primitives can be used in combination with the <code>TaskManager</code> and <code>TaskRouter</code> to control task execution in a distributed system (see more in Task Scheduler).</p>"},{"location":"sync/#backend","title":"Backend","text":"<p>You must load a synchronization backend before using synchronization primitives.</p> <p>Note</p> <p>Although Grelmicro use AnyIO for concurrency, the backends generally depend on <code>asyncio</code>, therefore Trio is not supported.</p> <p>You can initialize a backend like this:</p> RedisPostgresMemory (For Testing Only) <pre><code>from grelmicro.sync.redis import RedisSyncBackend\n\nbackend = RedisSyncBackend(\"redis://localhost:6379/0\")\n</code></pre> <pre><code>from grelmicro.sync.postgres import PostgresSyncBackend\n\nbackend = PostgresSyncBackend(\"postgresql://user:password@localhost:5432/db\")\n</code></pre> <pre><code>from grelmicro.sync.memory import MemorySyncBackend\n\nbackend = MemorySyncBackend()\n</code></pre> <p>Warning</p> <p>Please make sure to use a proper way to store connection url, such as environment variables (not like the example above).</p> <p>Tip</p> <p>Feel free to create your own backend and contribute it. In the <code>sync.abc</code> module, you can find the protocol for creating new backends.</p>"},{"location":"sync/#leader-election","title":"Leader Election","text":"<p>Leader election ensures that only one worker in the cluster is designated as the leader at any given time using a distributed lock.</p> <p>The leader election service is responsible for acquiring and renewing the distributed lock. It runs as an AnyIO Task that can be easily started with the Task Manager. This service operates in the background, automatically renewing the lock to prevent other workers from acquiring it. The lock is released automatically when the task is cancelled or during shutdown.</p> Task Manager (Recommended)AnyIO Task Group (Advanced) <pre><code>from grelmicro.sync import LeaderElection\nfrom grelmicro.task import TaskManager\n\nleader = LeaderElection(\"cluster_group\")\ntask = TaskManager()\ntask.add_task(leader)\n</code></pre> <pre><code>from anyio import create_task_group, sleep_forever\n\nfrom grelmicro.sync.leaderelection import LeaderElection\n\nleader = LeaderElection(\"cluster_group\")\n\n\nasync def main():\n    async with create_task_group() as tg:\n        await tg.start(leader)\n        await sleep_forever()\n</code></pre>"},{"location":"sync/#lock","title":"Lock","text":"<p>The lock is a distributed lock that can be used to synchronize access to shared resources.</p> <p>The lock supports the following features:</p> <ul> <li>Async: The lock must be acquired and released asynchronously.</li> <li>Distributed: The lock must be distributed across multiple workers.</li> <li>Reentrant: The lock must allow the same token to acquire it multiple times to extend the lease.</li> <li>Expiring: The lock must have a timeout to auto-release after an interval to prevent deadlocks.</li> <li>Non-blocking: Lock operations must not block the async event loop.</li> <li>Vendor-agnostic: Must support multiple backends (Redis, Postgres, ConfigMap, etc.).</li> </ul> <pre><code>from grelmicro.sync import Lock\n\nlock = Lock(\"resource_name\")\n\n\nasync def main():\n    async with lock:\n        print(\"Protected resource accessed\")\n</code></pre> <p>Warning</p> <p>The lock is designed for use within an async event loop and is not thread-safe or process-safe.</p>"},{"location":"task/","title":"Task Scheduler","text":"<p>The <code>task</code> package provides a simple task scheduler that can be used to run tasks periodically.</p> <p>Note: This is not a replacement for bigger tools like Celery, taskiq, or APScheduler. It is just lightweight, easy to use, and safe for running tasks in a distributed system with synchronization.</p> <p>The key features are:</p> <ul> <li>Fast &amp; Easy: Offers simple decorators to define and schedule tasks effortlessly.</li> <li>Interval Task: Allows tasks to run at specified intervals.</li> <li>Synchronization: Controls concurrency using synchronization primitives to manage simultaneous task execution (see the <code>sync</code> package).</li> <li>Dependency Injection: Use FastDepends library to inject dependencies into tasks.</li> <li>Error Handling: Catches and logs errors, ensuring that task execution errors do not stop the scheduling.</li> </ul>"},{"location":"task/#task-manager","title":"Task Manager","text":"<p>The <code>TaskManager</code> class is the main entry point to manage scheduled tasks. You need to start the task manager to run the scheduled tasks using the application lifespan.</p> FastAPIFastStream <pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom grelmicro.task import TaskManager\n\ntask = TaskManager()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    async with task:\n        yield\n\n\napp = FastAPI(lifespan=lifespan)\n</code></pre> <pre><code>from contextlib import asynccontextmanager\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.redis import RedisBroker\n\nfrom grelmicro.task import TaskManager\n\ntask = TaskManager()\n\n\n@asynccontextmanager\nasync def lifespan(context: ContextRepo):\n    async with task:\n        yield\n\n\nbroker = RedisBroker()\napp = FastStream(broker, lifespan=lifespan)\n</code></pre>"},{"location":"task/#interval-task","title":"Interval Task","text":"<p>To create an <code>IntervalTask</code>, use the <code>interval</code> decorator method of the <code>TaskManager</code> instance. This decorator allows tasks to run at specified intervals.</p> <p>Note: The interval specifies the waiting time between task executions. Ensure that the task execution duration is considered to meet deadlines effectively.</p> TaskManagerTaskRouter <pre><code>from grelmicro.task import TaskManager\n\ntask = TaskManager()\n\n\n@task.interval(seconds=5)\nasync def my_task():\n    print(\"Hello, World!\")\n</code></pre> <pre><code>from grelmicro.task import TaskRouter\n\ntask = TaskRouter()\n\n\n@task.interval(seconds=5)\nasync def my_task():\n    print(\"Hello, World!\")\n</code></pre>"},{"location":"task/#synchronization","title":"Synchronization","text":"<p>The Task can be synchronized using a Synchoronization Primitive to control concurrency and manage simultaneous task execution.</p> LockLeader Election <pre><code>from grelmicro.sync import Lock\nfrom grelmicro.task import TaskManager\n\nlock = Lock(\"my_task\")\ntask = TaskManager()\n\n\n@task.interval(seconds=5, sync=lock)\nasync def my_task():\n    async with lock:\n        print(\"Hello, World!\")\n</code></pre> <pre><code>from grelmicro.sync import LeaderElection\nfrom grelmicro.task import TaskManager\n\nleader = LeaderElection(\"my_task\")\ntask = TaskManager()\ntask.add_task(leader)\n\n\n@task.interval(seconds=5, sync=leader)\nasync def my_task():\n    async with leader:\n        print(\"Hello, World!\")\n</code></pre>"},{"location":"task/#task-router","title":"Task Router","text":"<p>For bigger applications, you can use the <code>TaskRouter</code> class to manage tasks in different modules.</p> <pre><code>\n</code></pre> <p>Then you can include the <code>TaskRouter</code> into the <code>TaskManager</code> or other routers using the <code>include_router</code> method.</p> <pre><code>from grelmicro.task.manager import TaskManager\n\ntask = TaskManager()\ntask.include_router(router)\n</code></pre> <p>Tip</p> <p>The <code>TaskRouter</code> follows the same philosophy as the <code>APIRouter</code> in FastAPI or the Router in FastStream.</p>"}]}